\documentclass[a4paper]{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\lstset{
	numbers=left
}

%%%%%%%%%%%%%%%%  TIPS - LATEX  %%%%%%%%%%%%%%%%%%%%%%%
% ° Afficher une photo:
%   - Toutes photos doivent etre dans le dossier src
%   - Tu peux modifier la taille (scale)
%
%\begin{figure}[!h]
%	\centering
%	\includegraphics[scale=0.8]{src/NOM_DU_FICHIER.png}
%	\caption{LEGENDE DE LA PHOTO (OBLIGATOIRE) }
%\end{figure}
%
%======================================================
%
% ° Faire un encadré:
%
% \fbox{
%	CONTENU ENCADRE
% }\\
%
%========================================================
% ° Inclure un code source/programme:
%	- Les parametres firstline et lastline ne sont pas obligatoire
%
% \fbox{
%	\lstinputlisting[language=Python,firstline=3, lastline=10]{../Bloc.py}
% }\\
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
	\centering
    \vspace*{0.5 cm} 
    \textsc{\LARGE Projet - Grammaires et langages}\\[1.0 cm]
    \textsc{\large Transformation et minimisation d'automate}\\[1.0 cm]
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	\includegraphics[scale=1]{src/logo.png}\\
	\vspace{0.5cm}
	\textsc{\Large Faculté des Sciences et Techniques}\\[0.2 cm]
	\textsc{\large Licence 3 Informatique }\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	\begin{minipage}{0.4\textwidth}
	\begin{flushright} \large
		\emph{Encadré par :}\\
		Pr Philippe GABORIT\\
		\end{flushright}
    	\begin{flushright} \large
		\emph{Réalisé par :}\\
		Nicolas NAN\\
		Jérémy DRON \\
		\end{flushright}
	\end{minipage}\\[2 cm]
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Algorithme de transformation d'un AFN en AFD}

En théorie des automates, il existe plusieurs types d'automates ayant des 
caractèristique bien défini:\\

\begin{itemize}
	\item \textbf{AFD [Automate Fini Déterministe]:} Une seule transition au plus pour 
	chaques symboles depuis un état
	\item \textbf{AFN [Automate Fini Non-déterministe]:} Automate pouvant posséder plusieurs
 transitions pour chaques symboles depuis un état
 	\item \textbf{AFN-$\epsilon$ [Automate Fini Non-Déterministe avec $\epsilon$ transition]:} Automate possédant des transitions
 	avec le symbole du vide\\
\end{itemize}

Il est possible de passer d'un type d'automate à un autre en lui appliquant quelques modifications. Pour
passer d'un AFN à un AFD, il faut créer des super-états qui seront la combinaisons de plusieurs états.
Un état sera final si un des états qui le compose l'est.Notre algorithme ne 
prendra en entrée que les automates suivant: \\

A=\{Q,$\epsilon$,$\delta$,$q_0$,F\}\\
Q => L'ensembles des états de l'automate avec $|Q|<=10$\\
$\epsilon$ => L'alphabet de symbole fini avec $\epsilon={a,b}$\\
$\delta$ => Transitions de l'automate\\
$q_0$ => L'etat initial de l'automate\\
F => L'ensemble des états finaux\\
\subsection{Représentation d'un automate et structure de données}

Dans un premier temps, il nous a fallu pouvoir représenter un automate de manière que notre
programme puisse le comprendre et l'utiliser. Pour cela, nous avons réaliser pour
chaques symboles une matrice. Ces matrices continennent uniquement des "0" ou des "1"
et chaques lignes indiquent l'état de départ d'une transition et chaque colonne l'état 
d'arrivé.\\

\begin{center}
   \begin{tabular}{| l ||*{4}{c|} }
     \hline
       & 0 & 1 & 2 & 3 \\ \hline\hline
     0 & 1 & 1 & 0 & 0 \\ \hline
     1 & 1 & 1 & 1 & 0 \\ \hline
     2 & 1 & 1 & 1 & 0 \\ \hline
     3 & 1 & 1 & 0 & 0 \\
     \hline
   \end{tabular}
 \end{center}
Le tableau ci-dessus représente un matrice concernant un symbole d'un automate.

\subsection{Principe de l'algorithme}
\subsection{Programme et execution}


\section{Algorithme de minimisation d'un automate}

A présent, nous cherchons à minimiser un AFD, cest-à-dire que nous
cherchons à avoir un automate avec le minimum d'état qui a le même
comportement que celui actuel. En effet, certains automates ont
des états qui peuvent être combiner entre-eux. Notre algorithme ne 
prendra en entrée que les automates suivant: \\

A=\{Q,$\epsilon$,$\delta$,$q_0$,F\}\\
Q => L'ensembles des états de l'automate avec $|Q|<=10$\\
$\epsilon$ => L'alphabet de symbole fini avec $\epsilon={a,b}$\\
$\delta$ => Transitions de l'automate\\
$q_0$ => L'etat initial de l'automate\\
F => L'etat final de l'automate\\



\subsection{Représentation d'un automate et structure de données}

Premièrement, nous avons cherché une représentation, pour notre
AFD, que notre programme pourrait facilement utiliser. Nous 
nous sommes alors basés de ce que nous avions trouvé dans la 
première partie.\\
Nous avons pour chaque symbole de notre alphabet une matrice lui correspondant. Dans
le cas précédent notre matrice contenait l'information de quels états
de départ pointaient sur quels états d'arrivés. Dans ce cas présent,
c'est l'inverse, nous cherchons à savoir quels états est pointés par
quels état. Du au fait, que nous travaillons uniquement avec des AFDs
nous pouvons concidérer que:\\

Soit M = "La matrice des transitions de départ vers arrivé"
alors $M^t$ = "La matrice des transitions des arrivés vers les départs"\\

Par ailleurs, pour minimiser notre automate nous avons utilisé l'algorithme vu
en cours. Dans notre programme nous utiliserons une file qui contiendra les
couples d'états à vérifier. Nous avons fait le choix de faire notre programme
dans le paradygme orienté objet pour une optimisation de la compléxité cognitive.
Nous avons réaliser le diagramme de classe de notre programme pour faciliter
la compréhension de la structure du programme.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.8]{src/diagramme_minimiseur.png}
	\caption{Diagramme de classe de notre minimiseur d'automate}
\end{figure}


\subsection{Principe de l'algorithme}

En premier lieu, l'utilisateur doit créer un objet de type \textit{Automate} et 
un objet de type \textit{Minimiseur} puis il peut utiliser deux méthodes:
une permettant de récuperer les états non distingables et l'autre le nombre
d'état de l'automate minimisé.\\

\fbox{
	\lstinputlisting[]{../Minimisation/main.py}
}\\

Concretement, l'objet \textit{Automate} prend un fichier en entrée qui contient des informations sur
l'automate ainsi la représentation de l'automate exprimé plus haut. Le fichier 
doit contenir sur la premier ligne le nombre d'état de l'automate, sur la deuxieme
ligne les états terminaux et finalement les matrices de transitions sur les lignes suivantes.
Le fichier peut ressembler à ça:\\

\fbox{
	\lstinputlisting[]{../Minimisation/automate.txt}
}\\

C'est grace à ce fichier que l'automate peut être charger dans le programme, donc le respect
de la forme est essentiel pour le fonctionnement.\\

Pour minimiser l'automate, le \textit{minimiseur} va initialiser la file avec les distingués
trivialement, i.e. les terminaux et non terminaux. Par la suite, le programme va générer de
nouveaux couples d'états distingués qu'il va ajouter en file si ces derniers n'existent pas
déjà. Le programme va parcourir toute la file jusqu'à arriver en tête avant de récuperer les
états des couples manquants. Pour connaitre le nombre d'état de l'automate final, le \textit{minimiseur}
soustrait au nombre d'état actuel le nombre d'état non distingué.\\

Pour trouver les états distingués engendré par un couple d'état passé en entrée de la fonction,
le programme vient recupérer grace
à la matrice les états pour lesquels il y a une transition avant de d'enregistrer dans la file toutes
les combinaisons d'états non existant. Si un état d'entrée engendre aucun état de sortie, càd
si un état ne possede pas de transition pour un symbole de l'alphabet, alors
le programme ignore les transitions de ce symbole pour cet état.

\fbox{
	\lstinputlisting[language=Python,firstline=43, lastline=73]{../Minimisation/Minimiseur.py}
}\\

Pour récuperer les couples manquants, le programme génère tous les couples possibles puis
il supprime un par un tous ceux qui existe dans notre file. Les couples qui restes sont ceux
qui n'existent pas en file donc ceux indistingables. Le programme vient effectuer l'opération
ensembliste suivantes:\\

	soit:\\
	$A=$\{Ensemble des couples d'états distingués que possède la file\}\\
	$\bar{A}=$\{Ensemble des couples d'états indistingués\}\\
	$\Omega=$\{Ensemble des couples d'états possibles\}\\

	Nous cherchons à avoir $\bar{A}$.\\

	$\bar{A}=\Omega-A$

Pour récuperer les états indistingables, il a suffit de prendre les états existant au moins
une fois dans les couples de $\bar{A}$.

\subsection{Programme et execution}

Dans cette partie, nous allons détailler quelques méthodes du programme permettant le bon
fonctionnement de l'algorithme décrit ci-avant puis allons mettre en pratique avec un exemple.\\

Notre programme tient essentiellement sur des matrices contenant des transitions d'état. Pour pouvoir
récuperer depuis un état les états qui pointent vers lui nous avons développé la methode 
\textit{indexes()}. Cette méthode recupère les numéros des colonnes de la matrice pour une ligne donnée.

\fbox{
	\lstinputlisting[language=Python,firstline=75, lastline=89]{../Minimisation/Minimiseur.py}
}\\

Avant de pouvoir ajouter en file tous les états distingués engendré par un couple d'état, il faut
pouvoir trouver toutes les combinaisons de couples d'états. Pour cela la méthode \textit{toutesCombinaisons()}
permet d'associer les états entre-eux.\\

\fbox{
	\lstinputlisting[language=Python,firstline=91, lastline=102]{../Minimisation/Minimiseur.py}
}\\

Cette méthode se contente uniquement de faire toutes les combinaisons possibles, c'est la méthode appelante
qui va gérer les doublons par exemple.\\

\textbf{\underline{Exemple:\\}}

Concidérons l'automate suivant:\\


\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.8]{src/auto1.png}
	\caption{Automate du premier exemple}
\end{figure}

La représentation de notre automate pour le programme sera la suivante:\\

\fbox{
	\lstinputlisting[]{../Minimisation/automate.txt}
}\\

Grace au fichier l'automate est chargé correctement dans le programme.\\

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.4]{src/autoCharge.png}
	\caption{Automate chargé en mémoire du programme}
\end{figure}

Nous pouvons constater que toutes les informations sont chargées en mémoire
et les transitions sont les transposées des matrices du fichier. Par ailleurs, 
nous pouvons observer la file durant l'execution et voir qu'elle contient
les couples de l'initialisation et ceux trouvés lors du déroulement

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{src/fileExecution.png}
	\caption{Une partie de la file à la fin de l'execution}
\end{figure}

Après execution de notre programme, nous obtenons la sortie suivante qui correspond à ce
que nous avions trouvé lors de notre recherche manuel en amont.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{src/resultat_auto1.png}
	\caption{Affichage du programme pour l'automate de l'exemple}
\end{figure}


\end{document}
